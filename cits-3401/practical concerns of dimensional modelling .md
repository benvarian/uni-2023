- kimballs four steps dimensional modeling 
	- identify the process being modelled 
	- determine the grain at which facts will be stored 
	- choose the dimensions 
	- identify the numeric measures for the facts 


- running example - retail sales 
	- grocery store chain recording POS retail sales 
	- 100 grocery stores in 5 states 
	- ~60,000 product SKUs 
		- SKU stock keeping unit 
		- represents an individual product 
	- goal: understand impact of pricing & promotions on sales, profits 
- step 1: retail sales questions 
	- whis is the lift due to a promotion
		- lift = gain in sales in a product because its being promoted 
		- requires estimated baseline sales value 
	- detect time shifting
		- customers stock up on the product thats on sale 
		- then they dont buy more of it for a long time 
	- detect cannibalisation 
		- cusomters buy the promoted product instead of competing products 
		- promoting brand A reduces sales of brand B 
	- detect cross-sell of complementary products 
		- promoting charcoal increases sales of lighter fluid 
	- what is the profitability of a promotion 
- step 2: grain of a fact table 
	- grain of a fact table = the meaning of one fact table row 
	- determines the max level of detail of the warehouse 
	- example grain statements 
		- line item from a cash register receipt 
		- boarding pass to get on a flight 
		- daily snapshot of inventory level for a product in a warehouse 
		- seneor reading per minute for a sensor 
	- finer grained fact tables 
		- are more expressive 
		- have more rows 
	- trade-off between performance and expressiveness 
		- rule of thumb 
- step 3: choosing dimensions 
	- determine a candidate key based on the grain statement 
		- example 1
			- a student enrolled in a course 
			- course,student,term is a candidate key 
		- example 2 
			- line item from a cash register receipt 
			- transaction ID, product SKU is a candiate key

- date dimension 
	- nearly every data warehouse will have one 
	- typical grain: each row = 1 day 
		- for finer-grained time measurements, use seperate date and time-of-day dimensions 
	- properties of a date 
	- why use a date dimensions instead of a SQL timestamp 
		- capture interesting date properties 
		- avoid relying on special  date-handling SQL functions

- date dimension and sample rows 
	- ![[Screenshot 2023-03-27 at 4.26.55 pm.png]]

- flags and indicators as text 
	- use meaningful values for indicators
	- dimension table attributes serve as report labels and values appear in a drill-down query filter list

- time-of-day as a dimension or fact
	- ![[Screenshot 2023-03-27 at 4.28.12 pm.png]]

- surrogate keys 
	- primary keys of dimension tables should be surrogate keys, not natural keys 
	- natural key: a key that is meaninful to users 
	- surrogate key: a meaningless integer key that is assigned by the data warehouse 
	- avoid using natural keys or codes generated by operational systems 

- benefits of surrogate keys 
	- data warehouse insulated from changes to operational systems 
	- easy to integrate data from multiple systems
	- narrow dimension keys 
		- thinner fact table = better performance 
	- better handling of exceptional cases 
		- what is the value is unknown or TBD?
		- using null is a poor option
		- better option: explicit dimension rows for "unknown", "tbd", "n/a"
	- avoids tempting query writers to assume implicit semantics 

- degenerate dimension
	- a dimension key without a corresponding dimension table 
	- two options 
		- discard the dimension
			- a good option if the dimension isnt needed for analysis 
		- use a degenerate dimension
			- store the dimension identifier directly in the fact table 
			- don't create a seperate dimension table 
			- used for transaction ID, invoice number 


- what is the degenerate dimension 
	- ![[Screenshot 2023-03-27 at 4.38.39 pm.png]]

- how many dimensions 
	- refering to the retail example 
		- should 2 concepts be modeled as seperate dimensions or two attributes of the same dimension?
	- example: different types of promotions 
		- ads, discounts coupons, end-of-aisle displays 
		- option a: 4 dimensions 
			- seperate dimension for each type of promotion 
		- option b: 1 dimension
			- each dimension row captures a combination of ad, discount, coupon, and end-of-aisle display 
	- factors to consider 
		- how do the users think about the data
			- are an ad and a coupon seperate promotions or two aspects of the same promotion 
		- fewer dimensions = fewer tables -> good performance 
			- generally fewer tables = simpler design 
		- performance implications 
			- see following slides 

- how many dimensions - performance 
	- most OLAP queries are "i/o bound"
		- data-intensive not compute intensive 
		- reading the data from disk is the bottleneck for "typical" queries, on typical hardware 
	- size of data on disk, query performance 
	- dimensional modeling impacts storage requirements 

- performance implications 
	- lets consider the extremes 
	- assumption
		- 100 million fact rows 
		- 3 four-byte measurement columns in the fact table 
		- 100 dimensional attributes, average size = 20 bytes 
	- three modelling options 
		- one "everything" dimension 
		- each atttribute gets its own dimension table 
		- 5 dimension (date, product, store, promotion, transaction ID)

- option A: one everything dimension 
	- fact table will be very thin (16 bytes per row)
		- 3 four byte fact column 
		- 1 four byte foreign key to the everytihng dimension 
	- dimension table is very wide (2000 bytes per row)
		- 100 attributes * 20 bytes each 
	- dimension table has as many rows as a fact table 
	- total space = 1.6 gb fact + 200gb dimension 

- option b: each attribute gets its own dimension table 
	- ![[Screenshot 2023-03-28 at 10.25.24 am.png]]
- option c: 4 dimensions (date, product, store, promotion)
	- ![[Screenshot 2023-03-28 at 10.25.41 am.png]]

- summary of option a, b and c
	- a 
		- one everything dimension 
		- space comsumption 200gb
	- b
		- each attribute gets its own dimension table 
		- space consumption 21.2 gb 
	- c 
		- 4 dimensions 
		- (date, product, store, promotion)
		- space consumption 2.8gb

- why is option c the best?
	- attributes that pertain to the same logical object have a high degree of correlation 
		- correlated attributes (option c makes use of)
			- produce name, brand 
			- number of distinct combination = number of distinct products 
			- product name and brand are completetly correlated 
	- when attributes are semi-correlated, designer has a choice 
		- frequently, multiple types of promotion occur together 


-  slowly changing dimensions 
	- compared to fact tables, contents of dimension tables are relatively stable 
	- attribute values for existing dimension rows do occasiionaly change over time 
	- how to handle gradual changes to dimensions 
		- option 1: overwrite history 
			- simple to implement
		- option 2: preserve history 
			- accurate historical reporting 
			- pre-computed aggregates unaffected 
			- - dimension table will grow over time
	- option 2 requires surrogate keys 
		- store mapping from operational key to most current surrogate key in data staging area 

- to overwrite or not 
	- both choices are commonly used 
	- questions to ask 
		- does to performance impact of additional dimensino rows outweigh the benefit of preserving history 

- hybrid solutions 
	- we want to be able to report using either old or new values 
	- solution: create two dimension columns 
	- approach 1: previous district and current district 
		- allows reporting using either the old or the new scheme 
		- whenever district assignemnents change, all current district values are moved to previous district 
	- approach 2: historical district and current district 
		- allows reports with the original scheme or the current scheme 
		- when district assignement changes, do two things 

- dimension roles 
	- ![[Screenshot 2023-03-28 at 12.05.41 pm.png]]
	- ![[Screenshot 2023-03-28 at 12.06.08 pm.png]]

- junk dimension 
	- sometimes certain attributes dont fit nicely into any dimension 
	- you can create one or more miscellaneous dimesions 
		- group together several leftover attribtues as a dimension even if they arent logcally related 
		- reduces number of dimension tables, width of fact table 
		- works best if leftover attributes are 
			- few in number 
			- low in cardinality 
			- correlated 
	- some alternatives 
		- each leftover attribute becomes its own dimension 
		- eliminte leftover attriutes that are not useful 

- fact tables - what to store 
	- additive facts are easy to work with 
		- summing the fact value gives meaningful results 
		- additive facts 
			- quantity sold 
			- total dollar sales 
		- non-additive facts 
			- averages (average sales price, unit price)
			- percentages 
			- ratios
	- ![[Screenshot 2023-03-28 at 12.12.36 pm.png]]

- storing additive quantities 
	- store additive quantities in the fact table 
	- example 
		- dont store "unit price"
		- store quantity sold, and total price 
	- store additive summaries used for distributive aggregates 
		- numerator and denominator for averages, percentages, ratios 
	- big disadvantage of non-additive quantities 


- transactional vs snapshot facts 
	- trans
		- each fact row represents a discrete event 
		- provides the most granular, detailed information 
	- snapshot 
		- each fact row represents a point-in-time snapshot 
		- snapshots are taken at predefined time intervals 
		- provides a cumulative view 
		- used for continuous processes or measures of intensity 

- transactional vs snapshot example 
	- ![[Screenshot 2023-03-28 at 12.15.57 pm.png]]

- why snapshot facts?
	- snapshot view can be always derived from transactional fact, but not the other way around 
	- sampling is the only option for continuous processes 
	- data compression 
		- sometimes recording all transaciotnal activity may be too much data
	- query expressiveness 
		- some queries are much easier to ask/answer with snapshot fact

- semi-additive facts 
	- snapshot facts are semi-additive 
	- additive across non-date dimensions 
	- example 
		- total account balance for oct 1 = ok 
		- total account balance for brian = not ok 
	- averages 
		- example: average daily balance 
		- can be computed from snapshot fact 
			- first compute sum across all time periods 
			- then divide by the number of time periods 

- factless fact tables 
	- transactional fact tables dont have rows for non-events 
	- this has good and bad points 
		- good: take advantage of sparsity 
		- bad: no record of non-events 
	- factless fact table 
		- a fact table without numeric fact columns 
		- used to capture relationships between dimensions 
	- examples 
		- promotion coverage fact table 
			- which products were on promotion in which stores for which days? 
		- student/department mapping fact table 
			- what is the major field of study for each student?

- education factless fact tables 
	- ![[Screenshot 2023-03-28 at 12.30.54 pm.png]]

- international issues 
	- international organisations often have facts denomiated in different currencies 
	- reporting requirements may be diverse 
		- standard currency vs local currency 
		- historical exchange rate vs current exchance rate 
	- time zones cause a similar problem 
		- sometimes local time is most meaningful 
		- sometimes standardies time (GMT) is better 

- handling multiple currencies 
	- add a currency dimension to the fact table 
	- each currency denominated fact gets 2 fact columns 
		- one column uses the local currency of the transaction 
		- the other stores the equivalent value in the standard currency 
		- currency dimensoin is used to indicate the units being used in he local currency column
	- create a special currency conversion table 
		- store current conversion factor between each pair of currencies 
		- used to generate reports in any currency of interest 

- multi currency example 
	- ![[Screenshot 2023-03-28 at 3.48.04 pm.png]]